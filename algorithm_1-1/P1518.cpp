#include <bits/stdc++.h>
//全局变量、宏定义的名字最好要复杂一点，避免和库里其它的全局变量等发生冲突而影响结果
#define N_board 15 
//用一个最大尝试次数来记录，如果尝试的次数太多可判定为死循环，因为棋盘10*10，最多100个位置，4个方向
//所以两者各自最多有400种状态，也就是一共最多有160000种情况。
//如果过了这么多情况后还没相遇，那一定状态发生了循环，也就是永远不会相遇。
//实际上这个最大步数要小得多，至少本题用10005能过。
#define MAX_TRY 10005
using namespace std;

char board[N_board][N_board];
int F[3], C[3];
//表示方向的向量。board[i][j]表示棋盘i行j列的话，向上{-1,0}，下{1,0}，左{0,-1}，右{0,1}
//顺时针旋转，就是上――右――下――左――上――右――下――左……，用取模来模拟出循环。
int vectors[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};

int main(int argc, char const *argv[])
{
    int ans = 0;
    for(int i = 0; i < N_board; i++){//棋盘扩展，将边界也标为障碍，
        for(int j = 0; j < N_board; j++){
            board[i][j] = '*';
        }
    }
    //不知道为啥，洛谷用getchar不行，但是用cin就行了，应该是换行符等符号在本地和洛谷评测机格式不一致
    for(int i = 1; i <= 10; i++){
        for(int j = 1; j <= 10; j++){
            cin >> board[i][j];//cin忽略空白符
            if(board[i][j] == 'F'){
                F[0] = i;
                F[1] = j;
                F[2] = 0;
            }else if(board[i][j] == 'C'){
                C[0] = i;
                C[1] = j;
                C[2] = 0;
            }
        }
    }
    while(ans <= MAX_TRY && (C[0] != F[0] || C[1] != F[1])){
        ans++;
        //将要走到的下一个位置如果是障碍，就换方向，否则就向那个方向走
        //将走到的下一个位置的坐标，为当前位置坐标，加上相应的方向向量。
        if(board[F[0]+vectors[F[2]][0]][F[1]+vectors[F[2]][1]] == '*'){
            F[2] = (F[2] + 1) % 4;
        }else{
            F[0] += vectors[F[2]][0];
            F[1] += vectors[F[2]][1];
        }
        if(board[C[0]+vectors[C[2]][0]][C[1]+vectors[C[2]][1]] == '*'){
            C[2] = (C[2] + 1) % 4;
        }else{
            C[0] += vectors[C[2]][0];
            C[1] += vectors[C[2]][1];
        }
    }
    cout << (ans <= MAX_TRY ? ans : 0);
    return 0;
}

// 测试点，答案58
// .****...*.
// ..*......*
// *.........
// ..........
// *........*
// *.**.*..**
// F..*......
// ***....*.*
// .C.......*
// .......*.*

